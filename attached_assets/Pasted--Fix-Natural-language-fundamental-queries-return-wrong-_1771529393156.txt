## Fix: Natural language fundamental queries return wrong results + N/A fields

### Problem 1: Wrong stock recommended
User asked: "what stocks have had the biggest increases in fundamentals that are also flashing technical indicators that suggest a big imminent price move"

System returned DE (Deere) which has DECLINING revenue (-2.3% YoY). The user explicitly asked for INCREASING fundamentals. The orchestrator failed to translate the user's intent into the correct data filters.

### Problem 2: All fundamental fields showing N/A
DE is a mega-cap ($182B) — Revenue, EBITDA, Net Income, EPS, PE Ratio, PS Ratio all exist and are well-known. But the response shows all N/A. Either the deep enrichment didn't fetch these fields, or the compression layer stripped them, or the field names don't match what the frontend expects.

### Root Cause Analysis

**Routing issue:** The query "biggest increases in fundamentals + technical indicators for price move" should route to `custom_screen` intent with specific Finviz filters for improving fundamentals + technical breakout signals. But the `custom_screen` intent has no implementation — it falls through to a generic scan.

**Data issue:** The `wide_scan_and_rank` deep enrichment calls `stockanalysis.get_overview()` and `finnhub.get_earnings_surprises()`, but the fields may not be mapped correctly to the frontend schema. The frontend expects fields like `revenue_latest_q`, `ebitda`, `ebitda_margin`, `net_income`, `eps_surprise`, `fcf`, `pe_ratio`, `ps_ratio`, `ev_ebitda`. Check if these exact field names are populated.

### Fix: Three changes

#### 1. Add `custom_screen` as a working intent with Finviz filter translation

In `prompts.py`, update the ORCHESTRATION_PROMPT to give OpenAI better guidance for custom screen queries. Find the `custom_screen` intent description:

OLD:

"custom_screen": User specifies quantitative filters — "find stocks with revenue >30% and RSI <40". Specific screening criteria.


NEW:

"custom_screen": User specifies quantitative screening criteria — "find stocks with revenue >30% and RSI <40", "stocks with improving fundamentals and breakout signals", "best growth stocks with momentum". When the user describes WHAT KIND of stocks they want using fundamental AND/OR technical criteria, use this intent. Include a "screen_description" field in filters that describes what the user wants in plain English.


Also add this to the ORCHESTRATION_PROMPT's output format, inside the "filters" section:

screen_description: Plain English description of what the user wants (for custom_screen intent only). Example: "stocks with accelerating revenue growth that are also showing technical breakout signals"
fundamental_criteria: Array of fundamental requirements. Example: ["revenue_growth_yoy > 20%", "eps_growth > 15%", "positive_earnings"]
technical_criteria: Array of technical requirements. Example: ["rsi_below_70", "above_sma50", "volume_expansion", "macd_bullish"]


#### 2. Implement the custom_screen handler in `claude_agent.py`

Find `INTENT_TO_CATEGORY` (around line 1156) and add:
```python
        "custom_screen": "custom_screen",
```

Find `_gather_data()` (or `_gather_data_safe`) and add a handler for `custom_screen` category. When the category is `custom_screen`, translate the user's criteria into Finviz filters:

Add this method to the agent class:
```python
    async def _gather_custom_screen_data(self, query_info: dict) -> dict:
        """Handle custom_screen intent — translate user criteria to Finviz filters + enrichment."""
        plan = query_info.get("orchestration_plan", {})
        filters = plan.get("filters", {})
        screen_desc = filters.get("screen_description", "")
        fund_criteria = filters.get("fundamental_criteria", [])
        tech_criteria = filters.get("technical_criteria", [])
        
        # Build Finviz filter string from criteria
        finviz_parts = ["sh_avgvol_o300", "sh_price_o5"]  # Base: liquid stocks only
        
        # Map fundamental criteria to Finviz filters
        desc_lower = (screen_desc + " " + " ".join(fund_criteria)).lower()
        
        if any(w in desc_lower for w in ["revenue growth", "sales growth", "increasing revenue", "improving revenue", "accelerating revenue"]):
            finviz_parts.append("fa_salesqoq_o10")
        if any(w in desc_lower for w in ["earnings growth", "eps growth", "improving earnings", "increasing eps"]):
            finviz_parts.append("fa_epsqoq_o10")
        if any(w in desc_lower for w in ["high growth", "fast growing", "fastest growing", "biggest increase"]):
            finviz_parts.append("fa_salesqoq_o20")
        if any(w in desc_lower for w in ["profitable", "positive earnings", "positive margin"]):
            finviz_parts.append("fa_opermargin_pos")
        if any(w in desc_lower for w in ["undervalued", "low pe", "value"]):
            finviz_parts.append("fa_pe_u30")
        if any(w in desc_lower for w in ["small cap", "micro cap"]):
            finviz_parts.append("cap_smallover")
        if any(w in desc_lower for w in ["large cap", "mega cap", "blue chip"]):
            finviz_parts.append("cap_largeover")
        
        # Map technical criteria to Finviz filters
        tech_lower = (screen_desc + " " + " ".join(tech_criteria)).lower()
        
        if any(w in tech_lower for w in ["breakout", "new high", "52 week high", "price move", "imminent move"]):
            finviz_parts.append("ta_highlow52w_nh")
        elif any(w in tech_lower for w in ["above sma50", "uptrend", "momentum"]):
            finviz_parts.append("ta_sma50_pa")
        elif any(w in tech_lower for w in ["above sma200", "long term uptrend"]):
            finviz_parts.append("ta_sma200_pa")
        
        if any(w in tech_lower for w in ["oversold", "rsi low", "rsi below"]):
            finviz_parts.append("ta_rsi_ob30")
        if any(w in tech_lower for w in ["volume", "volume spike", "unusual volume"]):
            finviz_parts.append("sh_relvol_o1.5")
        if any(w in tech_lower for w in ["technical indicator", "flashing", "signal", "imminent"]):
            # Add multiple TA confirmation filters
            if "ta_sma50_pa" not in finviz_parts:
                finviz_parts.append("ta_sma50_pa")
        
        # Default: if user asked for fundamentals + technicals but we have no specific filters,
        # use a solid growth + momentum combo
        if len(finviz_parts) <= 2:
            finviz_parts.extend(["fa_salesqoq_o10", "ta_sma50_pa"])
        
        finviz_filter_str = ",".join(finviz_parts)
        print(f"[CUSTOM_SCREEN] Translated: '{screen_desc}' → Finviz: {finviz_filter_str}")
        print(f"[CUSTOM_SCREEN] Fund criteria: {fund_criteria}")
        print(f"[CUSTOM_SCREEN] Tech criteria: {tech_criteria}")
        
        # Run it through wide_scan_and_rank with investments-level enrichment
        # Override CATEGORY_FILTERS temporarily
        original_filters = self.data.CATEGORY_FILTERS.get("custom_screen")
        self.data.CATEGORY_FILTERS["custom_screen"] = {
            "filters": finviz_filter_str,
            "limit": 40,
            "enrich_top": 12,
            "fallback_filters": [
                finviz_filter_str.replace("fa_salesqoq_o20", "fa_salesqoq_o10") if "fa_salesqoq_o20" in finviz_filter_str else finviz_filter_str.replace("ta_highlow52w_nh", "ta_sma50_pa"),
            ],
        }
        
        try:
            result = await self.data.wide_scan_and_rank("custom_screen", filters)
            result["screen_description"] = screen_desc
            result["fundamental_criteria"] = fund_criteria
            result["technical_criteria"] = tech_criteria
            result["finviz_filters_used"] = finviz_filter_str
            return result
        finally:
            # Restore original
            if original_filters:
                self.data.CATEGORY_FILTERS["custom_screen"] = original_filters
            else:
                self.data.CATEGORY_FILTERS.pop("custom_screen", None)
```

Then wire it into `_gather_data()` or `_gather_data_safe()`. Find the category routing section and add:
```python
        elif category == "custom_screen":
            return await self._gather_custom_screen_data(query_info)
```

Also add `"custom_screen"` to the `SCORING_CATEGORIES` set in `handle_query()` (around line 384):
```python
        SCORING_CATEGORIES = {
            "market_scan", "trending", "investments", "fundamentals_scan",
            "squeeze", "social_momentum", "volume_spikes", "earnings_catalyst",
            "sector_rotation", "asymmetric", "bearish", "thematic",
            "small_cap_spec", "briefing", "crypto", "cross_market",
            "commodities", "dashboard", "cross_asset_trending", "best_trades",
            "custom_screen",  # ADD THIS
        }
```

Also add `"custom_screen"` to the PRESET_BUDGETS:
```python
    "custom_screen": {"max_points": 70, "max_seconds": 16, "allow_deep_dive": True},
```

#### 3. Fix the N/A fundamental fields — ensure deep enrichment data maps to frontend schema

In `market_data_service.py`, find the `deep_enrich` inner function inside `wide_scan_and_rank` (around line 988). The overview data from StockAnalysis needs to include all the fields the frontend expects. Check what `stockanalysis.get_overview()` returns and make sure these fields are present in the enriched candidate:

After the deep_enrich result is merged into base_data (around line 1054-1055):
```python
            if not isinstance(deep_data, Exception) and isinstance(deep_data, dict) and "error" not in deep_data:
                base_data.update(deep_data)
```

Add a field mapping normalization step right after this:
```python
            if not isinstance(deep_data, Exception) and isinstance(deep_data, dict) and "error" not in deep_data:
                base_data.update(deep_data)
                
                # Normalize fundamental field names for frontend compatibility
                overview = deep_data.get("overview", {})
                if isinstance(overview, dict):
                    field_mapping = {
                        "revenue": "revenue_latest_q",
                        "revenue_quarterly": "revenue_latest_q",
                        "revenueGrowthYoY": "revenue_yoy",
                        "revenue_growth_yoy": "revenue_yoy",
                        "revenueGrowth": "revenue_yoy",
                        "ebitda": "ebitda",
                        "ebitdaMargin": "ebitda_margin",
                        "ebitda_margin": "ebitda_margin",
                        "netIncome": "net_income",
                        "net_income": "net_income",
                        "epsSuprise": "eps_surprise",
                        "eps_surprise": "eps_surprise",
                        "epsSurprise": "eps_surprise",
                        "freeCashFlow": "fcf",
                        "free_cash_flow": "fcf",
                        "fcf": "fcf",
                        "peRatio": "pe_ratio",
                        "pe_ratio": "pe_ratio",
                        "forwardPE": "pe_ratio",
                        "psRatio": "ps_ratio",
                        "ps_ratio": "ps_ratio",
                        "priceToSales": "ps_ratio",
                        "evToEbitda": "ev_ebitda",
                        "ev_ebitda": "ev_ebitda",
                        "enterpriseToEbitda": "ev_ebitda",
                        "analystTarget": "analyst_target",
                        "analyst_target": "analyst_target",
                        "priceTarget": "analyst_target",
                        "price_target": "analyst_target",
                        "targetPrice": "analyst_target",
                    }
                    for source_key, target_key in field_mapping.items():
                        if source_key in overview and overview[source_key] is not None:
                            if target_key not in base_data or base_data[target_key] is None:
                                base_data[target_key] = overview[source_key]
                    
                    # Also flatten overview fields directly into base_data for frontend access
                    for key in ["market_cap", "sector", "industry", "pe_ratio", "ps_ratio", 
                                "revenue_growth", "eps_growth", "profit_margin", "beta",
                                "52_week_high", "52_week_low", "avg_volume", "shares_outstanding",
                                "dividend_yield", "analyst_rating", "price_target", "analyst_count"]:
                        if key in overview and overview[key] is not None:
                            if key not in base_data or base_data[key] is None:
                                base_data[key] = overview[key]
```

Also check what `stockanalysis.get_overview()` actually returns. In `stockanalysis_scraper.py`, find `get_overview` and verify it's returning the expected fields. If it returns camelCase keys (like `revenueGrowthYoY`), the mapping above will normalize them.

#### 4. Add the user's query to the response

In `claude_agent.py`, in `handle_query()`, add the original user prompt to the result dict. Find where the result is assembled (around line 547-558):
```python
        result["_routing"] = {
            "source": _locals.get("routing_source", "unknown"),
            ...
        }
```

Add:
```python
        result["user_query"] = user_prompt
```

This gives the frontend the original query text to display at the top of the response.