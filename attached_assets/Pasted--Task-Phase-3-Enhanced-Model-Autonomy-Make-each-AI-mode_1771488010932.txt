## Task: Phase 3 — Enhanced Model Autonomy

Make each AI model contribute more to the final output quality. Three changes:

1. OpenAI generates a "reasoning brief" that guides Claude's analysis focus
2. Grok contributes a lightweight "market mood" signal to Best Trades and Screeners (where it currently provides zero social context)
3. Claude receives the reasoning brief and mood signal as structured context

### Architecture Change

Current flow:
OpenAI classifies → Data gathering → Scoring → Compression → Claude reasons from scratch

New flow:
OpenAI classifies + generates reasoning brief → Data gathering (+ Grok mood in parallel) → Scoring → Compression (includes brief + mood) → Claude reasons with focus guidance

### CRITICAL NON-NEGOTIABLES
- Do NOT change any response schemas or frontend contracts
- Do NOT change how preset routing works — presets still bypass the classifier
- Do NOT change any display_type formats
- The reasoning brief is ADVISORY — Claude can disagree with it
- If OpenAI brief generation fails, fall back silently to current behavior
- If Grok mood fails, fall back silently — no empty outputs
- Keep the Grok mood call lightweight (single call, max 10s timeout, cached 3min)

---

### Change 1: OpenAI Reasoning Brief

#### 1A. Add a new prompt in `prompts.py`

Add this after ORCHESTRATION_PROMPT (around line 590):
```python
REASONING_BRIEF_PROMPT = """You are generating a REASONING BRIEF for a trading analyst AI. This brief will guide what the analyst focuses on when reviewing market data.

Based on the user's query and the orchestration plan, generate a brief that tells the analyst:
1. What the user ACTUALLY wants (not just the literal words — the underlying trading intent)
2. What to prioritize in the analysis (e.g., "focus on momentum confirmation" or "user wants value plays, weight fundamentals heavily")
3. Any specific lens to apply (e.g., "user mentioned swing trades — think in 2-5 day timeframes" or "user wants contrarian plays — highlight things the crowd is wrong about")
4. What NOT to waste time on (e.g., "skip macro overview, user just wants setups" or "don't recommend mega-caps, user wants small caps")

Output ONLY a JSON object:
{
    "user_intent_summary": "1 sentence: what the user actually wants",
    "analysis_focus": ["focus area 1", "focus area 2", "focus area 3"],
    "lens": "The specific analytical lens to apply (e.g., 'momentum-first', 'value-contrarian', 'catalyst-driven', 'technical-breakout')",
    "avoid": ["thing to skip 1", "thing to skip 2"],
    "timeframe_bias": "intraday | swing | position | long_term | none",
    "conviction_threshold": "high_only | medium_plus | include_speculative",
    "special_instructions": "Any query-specific guidance or null"
}

Be concise. This brief should be 200 words max total. The analyst is experienced — don't over-explain."""
```

#### 1B. Generate the brief in `claude_agent.py`

In the `handle_query()` method, after the routing/classification is done but BEFORE data gathering, generate the reasoning brief. Find this section (around line 315-330 in the preset path, and around line 355-365 in the freeform path):

Add a new method to the CaelynAgent class:
```python
async def _generate_reasoning_brief(self, user_prompt: str, plan: dict) -> dict | None:
    """Ask OpenAI to generate a reasoning brief that guides Claude's analysis focus.
    Returns brief dict or None on failure. Runs concurrently with data gathering."""
    if not self.openai_client:
        return None
    try:
        plan_summary = json.dumps({
            "intent": plan.get("intent"),
            "asset_classes": plan.get("asset_classes"),
            "active_modules": [k for k, v in plan.get("modules", {}).items() if v],
            "risk_framework": plan.get("risk_framework"),
            "response_style": plan.get("response_style"),
            "filters": plan.get("filters", {}),
        }, default=str)
        
        response = await asyncio.wait_for(
            asyncio.to_thread(
                self.openai_client.chat.completions.create,
                model="gpt-4o-mini",
                max_tokens=300,
                temperature=0.2,
                response_format={"type": "json_object"},
                messages=[
                    {"role": "system", "content": "Reply with ONLY valid JSON. No other text."},
                    {"role": "user", "content": (
                        f"{REASONING_BRIEF_PROMPT}\n\n"
                        f"User query: {user_prompt}\n"
                        f"Orchestration plan: {plan_summary}"
                    )},
                ],
            ),
            timeout=5.0,
        )
        text = response.choices[0].message.content.strip()
        brief = json.loads(text)
        print(f"[REASONING_BRIEF] Generated: focus={brief.get('analysis_focus', [])[:3]} lens={brief.get('lens', '?')}")
        return brief
    except Exception as e:
        print(f"[REASONING_BRIEF] Generation failed (non-fatal): {e}")
        return None
```

IMPORTANT: Use `gpt-4o-mini` NOT `gpt-4o` for the brief — it's a simple structured extraction task and mini is cheaper and faster.

Add the import for the new prompt at the top of claude_agent.py where other prompts are imported:
```python
from prompts import REASONING_BRIEF_PROMPT
```

#### 1C. Run the brief generation in parallel with data gathering

In `handle_query()`, for BOTH the preset path and the freeform path, start the brief generation concurrently with data gathering. Find the section where `_gather_data_safe` is called (around lines 348-382). Modify both code paths (preset and freeform) to run the brief in parallel.

For the preset path (around line 348-353):
```python
            if category == "chat":
                market_data = await self._gather_chat_context(user_prompt, query_info)
                reasoning_brief = None
            else:
                # Run reasoning brief generation in parallel with data gathering
                plan = query_info.get("orchestration_plan", {})
                brief_task = self._generate_reasoning_brief(user_prompt, plan)
                data_task = self._gather_data_safe(query_info)
                market_data, reasoning_brief = await asyncio.gather(
                    data_task, brief_task, return_exceptions=True
                )
                if isinstance(market_data, Exception):
                    print(f"[AGENT] Data gathering exception: {market_data}")
                    market_data = {"error": str(market_data)}
                if isinstance(reasoning_brief, Exception):
                    reasoning_brief = None
```

Apply the same pattern for the freeform path (around lines 376-382).

For the followup path (around line 309-314), just set `reasoning_brief = None`.

#### 1D. Pass the brief to Claude via the compressed data

In the section where compression happens (the code added in Phase 2), after `compress_for_claude()` is called, inject the reasoning brief:
```python
        # Inject reasoning brief into compressed data for Claude
        if reasoning_brief and isinstance(claude_data, dict):
            claude_data["_reasoning_brief"] = reasoning_brief
            print(f"[AGENT] Reasoning brief injected into Claude context")
```

#### 1E. Tell Claude about the reasoning brief in the system prompt

In `prompts.py`, add this to the SYSTEM_PROMPT (at the end, before the closing `"""`):
REASONING BRIEF (when present):
You may receive a "_reasoning_brief" field in the market data. This was generated by the orchestrator to help you focus your analysis. It tells you:

What the user actually wants (beyond the literal query)
What to prioritize and what to skip
The analytical lens to apply
Timeframe and conviction preferences

Use it as guidance, not gospel. If the data contradicts the brief, trust the data. If the brief says "focus on momentum" but the best setup you see is a value play, include the value play — just acknowledge the user's preference.
The brief exists to make your analysis more targeted, not to constrain your judgment.

---

### Change 2: Grok Lightweight Market Mood for Best Trades and Screeners

#### 2A. Add a new method to `xai_sentiment_provider.py`
```python
    async def get_market_mood_snapshot(self) -> dict:
        """
        Ultra-lightweight market mood check. Single Grok call, cached 3min.
        Returns overall market mood from X chatter — not ticker-specific.
        Used to add social context to Best Trades and Screeners.
        """
        from data.cache import cache
        
        cache_key = "xai:market_mood_snapshot"
        cached = cache.get(cache_key)
        if cached is not None:
            return cached
        
        prompt = """Search X for the overall stock market mood RIGHT NOW. What is the dominant sentiment among traders on X today?

Return ONLY a JSON object (no markdown, no backticks):
{
    "mood": "risk-on" | "risk-off" | "mixed" | "euphoric" | "fearful" | "choppy",
    "mood_score": -1.0 to 1.0,
    "dominant_narratives": ["narrative1", "narrative2", "narrative3"],
    "hot_sectors": ["sector1", "sector2"],
    "avoid_sectors": ["sector1"],
    "trader_consensus": "1-2 sentence summary of what traders on X are focused on right now",
    "contrarian_note": "Anything where X consensus looks wrong, or null"
}

Keep it tight. This is a mood check, not a full scan."""

        result = await self._call_grok_with_x_search(prompt)
        
        if result and isinstance(result, dict) and "error" not in result:
            cache.set(cache_key, result, 180)  # 3 min cache
        
        return result
```

#### 2B. Wire the mood into Best Trades pipeline

In `market_data_service.py`, in the `get_best_trades_scan()` method, add the mood fetch in parallel with Phase 1 discovery. Find where the Finviz screens are gathered (around line 1224):
```python
        results = await asyncio.gather(
            new_highs_task, unusual_vol_task, gainers_task, breakout_task, volume_task,
            most_active_task, oversold_task, volatile_task,
            return_exceptions=True,
        )
```

Add the Grok mood fetch as an additional parallel task. Before the `asyncio.gather`, add:
```python
        # Lightweight Grok market mood — runs in parallel with Finviz discovery
        mood_task = None
        if hasattr(self, 'xai') and self.xai:
            mood_task = asyncio.wait_for(
                self.xai.get_market_mood_snapshot(),
                timeout=10.0,
            )
```

Then add mood_task to the gather (handle it being None):
```python
        all_tasks = [new_highs_task, unusual_vol_task, gainers_task, breakout_task, volume_task,
                     most_active_task, oversold_task, volatile_task]
        if mood_task:
            all_tasks.append(mood_task)
        
        results = await asyncio.gather(*all_tasks, return_exceptions=True)
        
        new_highs = results[0] if not isinstance(results[0], Exception) else []
        unusual_vol = results[1] if not isinstance(results[1], Exception) else []
        gainers = results[2] if not isinstance(results[2], Exception) else []
        breakout = results[3] if not isinstance(results[3], Exception) else []
        vol_screen = results[4] if not isinstance(results[4], Exception) else []
        most_active = results[5] if not isinstance(results[5], Exception) else []
        oversold = results[6] if not isinstance(results[6], Exception) else []
        volatile = results[7] if not isinstance(results[7], Exception) else []
        
        market_mood = None
        if mood_task and len(results) > 8:
            mood_result = results[8]
            if not isinstance(mood_result, Exception) and isinstance(mood_result, dict):
                market_mood = mood_result
                print(f"[BEST_TRADES] Grok market mood: {mood_result.get('mood', '?')} (score={mood_result.get('mood_score', '?')})")
            else:
                print(f"[BEST_TRADES] Grok mood unavailable: {mood_result if isinstance(mood_result, Exception) else 'empty'}")
```

Then include market_mood in the return dict at the end of get_best_trades_scan (around line 1434). Add it to the return dict:
```python
            "market_mood_social": market_mood,
```

#### 2C. Wire the mood into Screener pipeline

In `run_deterministic_screener()`, do the same — add a parallel mood fetch at the start. Right after the Finviz discovery call (around line 3772):
```python
        # Parallel: Grok mood + Finviz discovery
        mood_task = None
        if hasattr(self, 'xai') and self.xai:
            mood_task = asyncio.wait_for(
                self.xai.get_market_mood_snapshot(),
                timeout=10.0,
            )
        
        try:
            if mood_task:
                candidates, market_mood = await asyncio.gather(
                    self.finviz._custom_screen(screen_url),
                    mood_task,
                    return_exceptions=True,
                )
                if isinstance(candidates, Exception):
                    candidates = []
                if isinstance(market_mood, Exception) or not isinstance(market_mood, dict):
                    market_mood = None
                else:
                    print(f"[SCREENER] Grok mood: {market_mood.get('mood', '?')}")
            else:
                candidates = await self.finviz._custom_screen(screen_url)
                market_mood = None
        except Exception as e:
            print(f"[SCREENER] Finviz discovery error: {e}")
            candidates = []
            market_mood = None
```

Include `market_mood` in the screener return dict (where it builds the final result, around the return statement):
```python
            "market_mood_social": market_mood,
```

#### 2D. Update the data compressors to include mood

In `data_compressor.py`, update `_compress_best_trades` and `_compress_screener` to pass through the mood:

In `_compress_best_trades`, add to the return dict:
```python
        "market_mood_social": data.get("market_mood_social"),
```

In `_compress_screener`, add to the return dict:
```python
        "market_mood_social": data.get("market_mood_social"),
```

---

### Change 3: Tell Claude How to Use the Mood

In `prompts.py`, add this to the SYSTEM_PROMPT (after the REASONING BRIEF section you just added):
SOCIAL MOOD SIGNAL (when present):
You may receive a "market_mood_social" field containing a real-time market mood snapshot from X/Twitter via Grok. This tells you:

Overall trader mood (risk-on, risk-off, fearful, euphoric, etc.)
Hot sectors traders are focused on
Sectors being avoided
Dominant narratives

Use this as a CONFIRMATION or DIVERGENCE signal:

If the mood aligns with the TA data, it strengthens conviction
If the mood diverges from the TA (e.g., euphoric mood but deteriorating technicals), flag this as a caution signal
If hot_sectors from the mood align with sectors of top picks, mention it as a tailwind
If avoid_sectors from the mood match a pick's sector, flag it as a headwind

Never let mood override strong TA signals. Mood is context, not conviction.

---

### Testing Checklist

1. **Best Trades** (`/trades`): 
   - Check logs for `[REASONING_BRIEF] Generated` and `[BEST_TRADES] Grok market mood`
   - Verify trades still render correctly — no schema changes
   - Claude's analysis should feel more focused/targeted

2. **All 6 Screener Presets**:
   - Check logs for `[SCREENER] Grok mood` 
   - Verify rows, top_picks, explain still populate correctly
   - Mood data should appear in Claude's observations when relevant

3. **Trending Now / Daily Briefing**:
   - These already have social data — verify reasoning brief generates but doesn't duplicate Grok calls
   - Output quality should be equal or better

4. **Freeform queries** (type something in the chatbar):
   - Check `[REASONING_BRIEF]` appears in logs
   - Verify the brief doesn't slow down response time (it runs in parallel)

5. **Failure resilience**:
   - Temporarily break the OpenAI API key — verify everything still works without the brief
   - Temporarily break the xAI API key — verify Best Trades and Screeners still return results without mood

6. **Run existing test suite**: `python -m pytest` — all tests must still pass

### Success Criteria

- `[REASONING_BRIEF]` log line on every non-chat, non-followup request
- `[BEST_TRADES] Grok market mood` on Best Trades runs (when xAI is available)
- `[SCREENER] Grok mood` on screener runs (when xAI is available)
- No increase in response time (brief + mood run in parallel with existing work)
- Claude's output feels more targeted — fewer generic observations, more focused thesis
- All existing tests pass
- All frontend rendering unchanged

