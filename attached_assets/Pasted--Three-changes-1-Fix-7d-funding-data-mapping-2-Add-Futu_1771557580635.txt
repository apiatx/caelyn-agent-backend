## Three changes: (1) Fix 7d/funding data mapping, (2) Add Futures Perps section to crypto response, (3) Enable crypto via natural language chat

### CHANGE 1: Fix the data mapping in the compressor

The HyperLiquid data structure in the crypto scanner is nested:
data["hyperliquid"] = {
"source": "Hyperliquid",
"funding_analysis": {
"market_summary": {...},
"crowded_longs": [...],
"squeeze_candidates": [...],
"funding_divergences": [...],
"top_by_open_interest": [...],
"top_gainers": [...],
"top_losers": [...]
},
"btc_funding_trend": {...},
"eth_funding_trend": {...}
}

In the crypto compressor (`_compress_crypto` in `data_compressor.py`), make sure the funding lookup navigates this structure correctly:
```python
    # Build funding rate lookup from HyperLiquid
    hl_raw = data.get("hyperliquid", {})
    funding_lookup = {}
    
    if isinstance(hl_raw, dict):
        # Navigate the nested structure
        funding_analysis = hl_raw.get("funding_analysis", {})
        if isinstance(funding_analysis, dict):
            # Scan all lists that contain per-coin funding data
            for source_key in ["top_by_open_interest", "crowded_longs", "squeeze_candidates", 
                               "funding_divergences", "top_gainers", "top_losers"]:
                items = funding_analysis.get(source_key, [])
                if isinstance(items, list):
                    for item in items:
                        coin = (item.get("coin") or "").upper()
                        if coin and coin not in funding_lookup:
                            funding_lookup[coin] = {
                                "funding_rate": item.get("funding_rate"),
                                "funding_annualized": item.get("funding_annualized") or item.get("funding_rate_annualized"),
                                "open_interest_usd": item.get("open_interest_usd"),
                            }
    
    print(f"[CRYPTO_COMPRESS] Funding lookup: {len(funding_lookup)} coins: {list(funding_lookup.keys())[:15]}")
```

Then when building top_coins, cross-reference:
```python
    top_coins_raw = data.get("cg_top_coins", [])
    compressed["top_coins"] = []
    for c in (top_coins_raw or [])[:15]:
        symbol = (c.get("symbol") or "").upper()
        hl = funding_lookup.get(symbol, {})
        
        coin_entry = {
            "symbol": symbol,
            "name": c.get("name"),
            "price": c.get("current_price"),
            "change_24h": c.get("price_change_percentage_24h"),
            "change_7d": c.get("price_change_percentage_7d_in_currency"),
            "change_30d": c.get("price_change_percentage_30d_in_currency"),
            "market_cap": c.get("market_cap"),
            "volume_24h": c.get("total_volume"),
            "funding_rate": hl.get("funding_rate"),
            "funding_annualized": hl.get("funding_annualized"),
            "open_interest_usd": hl.get("open_interest_usd"),
        }
        compressed["top_coins"].append(coin_entry)
    
    # Log first coin to verify 7d and funding populated
    if compressed["top_coins"]:
        s = compressed["top_coins"][0]
        print(f"[CRYPTO_COMPRESS] First coin: {s['symbol']} price={s['price']} 7d={s['change_7d']} funding={s['funding_rate']}")
```

### CHANGE 2: Add Futures/Perps section to crypto response

The HyperLiquid provider has `get_all_perps()` which returns EVERY perpetual future with real-time data (mark price, funding rate, OI, volume, 24h change, premium, max leverage). This is the user's primary trading venue.

**Step A: Add a perps summary to the compressed data**

In the crypto compressor, add a new `perps_overview` section using HyperLiquid data:
```python
    # === FUTURES/PERPS SECTION (HyperLiquid) ===
    hl_fa = hl_raw.get("funding_analysis", {}) if isinstance(hl_raw, dict) else {}
    
    compressed["perps_overview"] = {
        "source": "Hyperliquid",
        "market_summary": hl_fa.get("market_summary", {}),
        "btc_funding_trend": hl_raw.get("btc_funding_trend", {}),
        "eth_funding_trend": hl_raw.get("eth_funding_trend", {}),
    }
    
    # Top perps by volume (most active futures)
    compressed["perps_top_volume"] = [
        {
            "coin": g.get("coin"),
            "price_change_24h": g.get("price_change_24h"),
            "funding_rate": g.get("funding_rate"),
            "volume_24h_usd": g.get("volume_24h_usd"),
        }
        for g in sorted(
            hl_fa.get("top_by_open_interest", []),
            key=lambda x: x.get("volume_24h_usd", 0), reverse=True
        )[:10]
    ]
    
    # Top perps by OI (where the money is positioned)
    compressed["perps_top_oi"] = [
        {
            "coin": o.get("coin"),
            "open_interest_usd": o.get("open_interest_usd"),
            "funding_rate": o.get("funding_rate"),
            "price_change_24h": o.get("price_change_24h"),
            "volume_24h_usd": o.get("volume_24h_usd"),
        }
        for o in (hl_fa.get("top_by_open_interest") or [])[:10]
    ]
    
    # Squeeze candidates (highest-signal trades)
    compressed["perps_squeezes"] = [
        {
            "coin": s.get("coin"),
            "funding_rate": s.get("funding_rate"),
            "funding_annualized": s.get("funding_annualized"),
            "open_interest_usd": s.get("open_interest_usd"),
            "price_change_24h": s.get("price_change_24h"),
            "signal": s.get("signal"),
        }
        for s in (hl_fa.get("squeeze_candidates") or [])[:8]
    ]
    
    # Crowded longs (liquidation risk)
    compressed["perps_crowded_longs"] = [
        {
            "coin": l.get("coin"),
            "funding_rate": l.get("funding_rate"),
            "funding_annualized": l.get("funding_annualized"),
            "open_interest_usd": l.get("open_interest_usd"),
            "price_change_24h": l.get("price_change_24h"),
            "signal": l.get("signal"),
        }
        for l in (hl_fa.get("crowded_longs") or [])[:8]
    ]
    
    # Funding divergences (price vs funding)
    compressed["perps_divergences"] = [
        {
            "coin": d.get("coin"),
            "type": d.get("type"),
            "funding_rate": d.get("funding_rate"),
            "price_change_24h": d.get("price_change_24h"),
            "signal": d.get("signal"),
        }
        for d in (hl_fa.get("funding_divergences") or [])[:5]
    ]
    
    # Top gainers/losers on perps
    compressed["perps_gainers"] = (hl_fa.get("top_gainers") or [])[:5]
    compressed["perps_losers"] = (hl_fa.get("top_losers") or [])[:5]
```

**Step B: Update the crypto response schema in prompts.py**

Find the crypto display_type schema (around line 397-398). Add the perps section:
```json
"perps_overview": {
    "source": "Hyperliquid",
    "total_open_interest": "",
    "total_volume_24h": "",
    "avg_funding_rate": "",
    "market_bias": "",
    "btc_funding_trend": "",
    "eth_funding_trend": ""
},
"perps_top_volume": [{"coin": "", "volume_24h": "", "funding_rate": "", "change_24h": ""}],
"perps_squeezes": [{"coin": "", "funding_rate": "", "funding_annualized": "", "signal": "", "open_interest": ""}],
"perps_crowded_longs": [{"coin": "", "funding_rate": "", "signal": ""}],
"perps_divergences": [{"coin": "", "type": "", "funding_rate": "", "price_change": "", "signal": ""}]
```

**Step C: Update Claude's crypto prompt to include perps analysis**

Add to the crypto preamble:
FUTURES/PERPS ANALYSIS (from HyperLiquid — user's primary trading venue):
You MUST include a dedicated "perps_overview" section in your response using HyperLiquid data:

Market summary: total OI, total volume, avg funding rate, market bias
BTC and ETH funding trends (3-day trend: increasing/decreasing/stable)
Top perps by volume — show the most active futures contracts
Squeeze candidates — coins with extreme negative funding while price is rising. These are the HIGHEST SIGNAL trades.
Crowded longs — coins where longs are overextended (liquidation risk)
Funding divergences — price moving opposite to funding direction

The perps data is in: perps_overview, perps_top_volume, perps_top_oi, perps_squeezes, perps_crowded_longs, perps_divergences, perps_gainers, perps_losers.
For each squeeze/divergence, include the specific funding rate and what it means for trade direction.

### CHANGE 3: Enable crypto queries via natural language chat

When a user types something like "what's happening in crypto" or "show me BTC funding rates" in the chat bar (not clicking the preset), it needs to route to the crypto scanner.

In `claude_agent.py`, find `_classify_simple()` method. Make sure crypto keyword detection is EARLY and STRONG:
```python
    def _classify_simple(self, prompt: str) -> dict | None:
        q = prompt.lower().strip()
        
        # ... existing checks ...
        
        # Crypto-specific queries ALWAYS route to crypto scanner
        # Check this BEFORE any cross-market detection
        crypto_exclusive = [
            "crypto market", "crypto scan", "crypto sentiment", "crypto fear",
            "funding rate", "perps", "perpetual", "altcoin", "altcoins",
            "defi", "hot categories", "crypto momentum", "crypto hype",
            "bitcoin dominance", "btc dominance", "btc.d", "eth.d",
            "short squeeze crypto", "crypto squeeze", "funding divergence",
            "hyperliquid", "what's happening in crypto", "crypto overview",
            "crypto analysis", "meme coins", "meme coin", "shitcoins",
        ]
        if any(s in q for s in crypto_exclusive):
            return {"category": "crypto"}
        
        # Single crypto keywords (only if no stock/commodity signals)
        crypto_words = ["crypto", "bitcoin", "btc", "eth", "ethereum", "solana", "sol"]
        has_crypto = any(w in q.split() for w in crypto_words)
        has_stock = any(s in q for s in ["stock", "equit", "spy", "nasdaq", "s&p"])
        has_commodity = any(s in q for s in ["gold", "oil", "silver", "commodit"])
        
        if has_crypto and not has_stock and not has_commodity:
            return {"category": "crypto"}
```

Also make sure `_detect_cross_market()` doesn't hijack pure crypto queries. Find `_detect_cross_market()` and add a guard:
```python
    def _detect_cross_market(self, q: str) -> dict | None:
        # Pure crypto queries should NOT be overridden to cross_market
        crypto_exclusive = ["funding rate", "perps", "crypto scan", "crypto market",
                           "altcoin", "defi", "crypto sentiment", "hyperliquid"]
        if any(s in q for s in crypto_exclusive):
            return None
        
        # ... rest of existing logic ...
```

### Testing

1. Click "Crypto" in sidebar → response should include:
   - BTC/ETH with 7d change (not N/A)
   - BTC/ETH with funding rates (not blank)
   - A "Futures/Perps" section with HyperLiquid data
   - Squeeze candidates with funding rates
   - Crowded longs with liquidation risk flags
2. Check logs: `[CRYPTO_COMPRESS] First coin: BTC price=67000 7d=-2.3 funding=0.0001`
3. Check logs: `[CRYPTO_COMPRESS] Funding lookup: 50+ coins`
4. Type "what's happening in crypto" in chat bar → routes to crypto scanner (NOT trending)
5. Type "show me BTC funding rates" → routes to crypto
6. Type "crypto squeeze candidates" → routes to crypto
7. Type "best stocks and crypto" → routes to cross_market (correct)
8. All other presets still work
9. `python -m pytest` passes