STEP 1: Add the Secret
In the Secrets panel, add:

Key: COINGECKO_API_KEY
Value: (paste your demo API key)

STEP 2: Update config.py
pythonCOINGECKO_API_KEY = os.getenv("COINGECKO_API_KEY")
STEP 3: Create the CoinGecko Provider
Create a new file data/coingecko_provider.py:
python"""
CoinGecko API provider for crypto market data.
Demo plan: 10,000 calls/month, 30 calls/min.
Covers: spot prices, market data, trending coins, top gainers/losers,
derivatives (funding rates, open interest), social/dev metrics.
"""
import httpx
from data.cache import cache

CRYPTO_CACHE_TTL = 120  # 2 minutes — crypto moves fast


class CoinGeckoProvider:
    BASE_URL = "https://api.coingecko.com/api/v3"

    def __init__(self, api_key: str):
        self.api_key = api_key

    async def _get(self, endpoint: str, params: dict = None) -> dict | list:
        if params is None:
            params = {}
        params["x_cg_demo_api_key"] = self.api_key

        cache_key = f"coingecko:{endpoint}:{str(sorted(params.items()))[:80]}"
        cached = cache.get(cache_key)
        if cached is not None:
            return cached

        try:
            async with httpx.AsyncClient() as client:
                resp = await client.get(
                    f"{self.BASE_URL}/{endpoint}",
                    params=params,
                    timeout=15,
                )
            if resp.status_code == 429:
                print("CoinGecko rate limit hit")
                return []
            if resp.status_code != 200:
                print(f"CoinGecko error {resp.status_code}: {endpoint}")
                return []
            data = resp.json()
            cache.set(cache_key, data, CRYPTO_CACHE_TTL)
            return data
        except Exception as e:
            print(f"CoinGecko request failed ({endpoint}): {e}")
            return []

    # ── Spot Market Data ──────────────────────────

    async def get_top_coins(self, limit: int = 50) -> list:
        """
        Top coins by market cap with full market data.
        Returns: price, market_cap, volume, 24h change, 7d change,
        ATH, ATL, circulating supply, total supply.
        ~1 API call.
        """
        return await self._get("coins/markets", {
            "vs_currency": "usd",
            "order": "market_cap_desc",
            "per_page": limit,
            "page": 1,
            "sparkline": "false",
            "price_change_percentage": "1h,24h,7d,30d",
        })

    async def get_trending(self) -> dict:
        """
        Trending coins on CoinGecko (based on search traffic).
        Good proxy for retail attention/momentum.
        ~1 API call.
        """
        return await self._get("search/trending")

    async def get_coin_detail(self, coin_id: str) -> dict:
        """
        Full detail for a single coin including:
        - Description, links, social stats
        - Developer data (GitHub commits, stars, forks)
        - Community data (Twitter followers, Reddit subscribers)
        - Market data (price, volume, market cap, ATH, ATL)
        ~1 API call.
        """
        return await self._get(f"coins/{coin_id}", {
            "localization": "false",
            "tickers": "false",
            "market_data": "true",
            "community_data": "true",
            "developer_data": "true",
        })

    async def get_global_market(self) -> dict:
        """
        Global crypto market overview: total market cap, BTC dominance,
        total volume, number of active coins, market cap change 24h.
        ~1 API call.
        """
        data = await self._get("global")
        return data.get("data", {}) if isinstance(data, dict) else {}

    async def get_global_defi(self) -> dict:
        """Global DeFi market data."""
        data = await self._get("global/decentralized_finance_defi")
        return data.get("data", {}) if isinstance(data, dict) else {}

    # ── Derivatives / Perps Data ──────────────────

    async def get_derivatives_tickers(self) -> list:
        """
        All derivatives tickers across exchanges.
        Returns: symbol, price, funding_rate, open_interest,
        volume_24h, spread, index price.
        ~1 API call. Returns up to 100 tickers.
        """
        return await self._get("derivatives")

    async def get_derivatives_exchange(self, exchange_id: str = "binance_futures") -> dict:
        """
        Detailed derivatives data for a specific exchange.
        Includes ALL perpetual tickers with funding rates and OI.
        ~1 API call.
        """
        return await self._get(f"derivatives/exchanges/{exchange_id}", {
            "include_tickers": "all",
        })

    # ── Categories & Gainers/Losers ────────────────

    async def get_categories(self) -> list:
        """
        All crypto categories with market data.
        Shows which sectors/narratives are hot (DeFi, AI, L2, memes, etc.).
        ~1 API call.
        """
        return await self._get("coins/categories", {
            "order": "market_cap_change_24h_desc",
        })

    async def get_top_gainers_losers(self) -> dict:
        """
        Get top gainers and losers in the last 24h.
        Uses top coins endpoint sorted by change.
        ~2 API calls.
        """
        # Get top 100 coins, then sort client-side
        coins = await self.get_top_coins(100)
        if not coins:
            return {"gainers": [], "losers": []}

        valid = [c for c in coins if c.get("price_change_percentage_24h") is not None]
        sorted_coins = sorted(valid, key=lambda x: x.get("price_change_percentage_24h", 0), reverse=True)

        gainers = sorted_coins[:15]
        losers = sorted_coins[-15:][::-1]  # Worst first

        return {"gainers": gainers, "losers": losers}

    # ── Combined Crypto Dashboard ──────────────────

    async def get_crypto_dashboard(self) -> dict:
        """
        Full crypto market scan:
        Global market data + top coins + trending + derivatives + categories.
        Uses ~6-8 API calls.
        """
        import asyncio

        global_data, top_coins, trending, derivatives, categories, gainers_losers = (
            await asyncio.gather(
                self.get_global_market(),
                self.get_top_coins(50),
                self.get_trending(),
                self.get_derivatives_tickers(),
                self.get_categories(),
                self.get_top_gainers_losers(),
                return_exceptions=True,
            )
        )

        return {
            "global_market": global_data if not isinstance(global_data, Exception) else {},
            "top_coins": top_coins if not isinstance(top_coins, Exception) else [],
            "trending": trending if not isinstance(trending, Exception) else {},
            "derivatives": derivatives if not isinstance(derivatives, Exception) else [],
            "categories": categories if not isinstance(categories, Exception) else [],
            "gainers_losers": gainers_losers if not isinstance(gainers_losers, Exception) else {},
        }

    async def get_coin_deep_dive(self, coin_ids: list) -> dict:
        """
        Deep enrichment for specific coins — social stats, dev activity,
        community metrics. Up to 10 coins.
        ~1 API call per coin.
        """
        import asyncio
        results = await asyncio.gather(
            *[self.get_coin_detail(cid) for cid in coin_ids[:10]],
            return_exceptions=True,
        )
        enriched = {}
        for coin_id, result in zip(coin_ids[:10], results):
            if not isinstance(result, Exception) and isinstance(result, dict):
                enriched[coin_id] = result
        return enriched
STEP 4: Wire CoinGecko into Market Data Service
In data/market_data_service.py, add the import at the top:
pythonfrom data.coingecko_provider import CoinGeckoProvider
In the __init__ method, add the parameter and initialization:
Add coingecko_key: str = None to the method signature.
Add inside the method body:
python        self.coingecko = CoinGeckoProvider(coingecko_key) if coingecko_key else None
Add the crypto scan method to the class:
python    async def get_crypto_scanner(self) -> dict:
        """
        Full crypto market scan combining:
        CoinGecko (spot + derivatives + social + categories) +
        Alpha Vantage (news sentiment) + Fear & Greed.
        """
        import asyncio

        if not self.coingecko:
            return {"error": "CoinGecko API not configured"}

        # Main CoinGecko data
        cg_dashboard = await self.coingecko.get_crypto_dashboard()

        # Get deep dive for top trending coins + top movers
        trending_coins = []
        if isinstance(cg_dashboard.get("trending"), dict):
            coins_list = cg_dashboard["trending"].get("coins", [])
            trending_coins = [c.get("item", {}).get("id", "") for c in coins_list[:6] if c.get("item")]

        top_gainers = []
        gl = cg_dashboard.get("gainers_losers", {})
        if isinstance(gl, dict):
            for g in (gl.get("gainers") or [])[:4]:
                cid = g.get("id")
                if cid and cid not in trending_coins:
                    top_gainers.append(cid)

        deep_dive_ids = list(dict.fromkeys(trending_coins + top_gainers))[:10]
        deep_dive = {}
        if deep_dive_ids:
            deep_dive = await self.coingecko.get_coin_deep_dive(deep_dive_ids)

        # Parse derivatives for funding rate analysis
        derivatives = cg_dashboard.get("derivatives", [])
        funding_analysis = self._analyze_funding_rates(derivatives)

        # Fear & Greed (crypto-correlated)
        fear_greed = {}
        try:
            fear_greed = await self.fear_greed.get_fear_greed_index()
        except:
            pass

        # Crypto news sentiment via Alpha Vantage
        crypto_news = {}
        try:
            crypto_news = await self.alphavantage.get_news_sentiment("CRYPTO:BTC")
        except:
            pass

        return {
            "global_market": cg_dashboard.get("global_market", {}),
            "top_coins": cg_dashboard.get("top_coins", []),
            "trending": cg_dashboard.get("trending", {}),
            "gainers_losers": cg_dashboard.get("gainers_losers", {}),
            "categories": (cg_dashboard.get("categories") or [])[:20],
            "derivatives_tickers": derivatives[:30],
            "funding_analysis": funding_analysis,
            "deep_dive": deep_dive,
            "fear_greed": fear_greed if not isinstance(fear_greed, Exception) else {},
            "crypto_news": crypto_news if not isinstance(crypto_news, Exception) else {},
        }

    def _analyze_funding_rates(self, derivatives: list) -> dict:
        """
        Analyze funding rates across all perpetual tickers.
        Positive funding = longs paying shorts (bullish crowding).
        Negative funding = shorts paying longs (bearish crowding or squeeze potential).
        Extreme funding = potential reversal signal.
        """
        if not derivatives or not isinstance(derivatives, list):
            return {}

        perps = [d for d in derivatives if d.get("contract_type") == "perpetual" and d.get("funding_rate") is not None]

        if not perps:
            return {}

        # Sort by funding rate
        sorted_by_funding = sorted(perps, key=lambda x: x.get("funding_rate", 0), reverse=True)

        # Highest funding (most crowded longs — reversal risk)
        highest_funding = [{
            "symbol": p.get("symbol", ""),
            "funding_rate": p.get("funding_rate"),
            "open_interest": p.get("open_interest"),
            "volume_24h": p.get("h24_volume"),
            "price": p.get("last"),
            "change_24h": p.get("h24_percentage_change"),
            "signal": "Crowded longs — correction risk" if p.get("funding_rate", 0) > 0.03 else "Elevated long bias",
        } for p in sorted_by_funding[:10]]

        # Most negative funding (crowded shorts — squeeze potential)
        lowest_funding = [{
            "symbol": p.get("symbol", ""),
            "funding_rate": p.get("funding_rate"),
            "open_interest": p.get("open_interest"),
            "volume_24h": p.get("h24_volume"),
            "price": p.get("last"),
            "change_24h": p.get("h24_percentage_change"),
            "signal": "Crowded shorts — squeeze potential" if p.get("funding_rate", 0) < -0.01 else "Short bias",
        } for p in sorted_by_funding[-10:]]

        # Average funding across all perps
        avg_funding = sum(p.get("funding_rate", 0) for p in perps) / len(perps) if perps else 0

        # Highest OI (most liquid/active perps)
        sorted_by_oi = sorted(perps, key=lambda x: x.get("open_interest", 0) or 0, reverse=True)
        highest_oi = [{
            "symbol": p.get("symbol", ""),
            "open_interest": p.get("open_interest"),
            "funding_rate": p.get("funding_rate"),
            "volume_24h": p.get("h24_volume"),
        } for p in sorted_by_oi[:10]]

        return {
            "total_perps_tracked": len(perps),
            "avg_funding_rate": round(avg_funding, 6),
            "market_bias": "Bullish (longs paying)" if avg_funding > 0.005 else "Bearish (shorts paying)" if avg_funding < -0.005 else "Neutral",
            "highest_funding": highest_funding,
            "most_negative_funding": lowest_funding,
            "highest_open_interest": highest_oi,
        }
STEP 5: Update main.py
Add to imports and pass to MarketDataService:
pythonfrom config import COINGECKO_API_KEY
Add coingecko_key=COINGECKO_API_KEY to the MarketDataService constructor call.
STEP 6: Add Crypto Route in Agent
In agent/claude_agent.py, add to _gather_data:
python        elif category == "crypto":
            return await self.data.get_crypto_scanner()
```

### STEP 7: Add Crypto to Classifier

**In `agent/prompts.py`, in `QUERY_CLASSIFIER_PROMPT`, add:**
```
- "crypto": User asks about cryptocurrency, Bitcoin, Ethereum, altcoins, crypto market, DeFi, funding rates, perpetuals, on-chain data, crypto momentum, meme coins, or any specific crypto token/coin.
```

### STEP 8: Add Crypto Display Format to System Prompt

**In `agent/prompts.py`, add this format before `### FORMAT 7: "chat"`:**
```
### FORMAT: "crypto" — Crypto Market Scanner
Use when: user asks about crypto, Bitcoin, altcoins, DeFi, funding rates, perpetuals.

Your analysis should cover:
1. Global crypto market state (total market cap, BTC dominance, 24h volume change)
2. Funding rate analysis (are longs or shorts crowded? Squeeze potential? Reversal signals?)
3. Which categories/narratives are leading (AI tokens, memes, L2s, DeFi, etc.)
4. Top momentum coins with social buzz acceleration
5. Asymmetric setups (negative funding + rising price = squeeze; high funding + stalling = long liquidation risk)
```json
{
  "display_type": "crypto",
  "market_overview": "Total crypto market cap $2.8T, up 3.2% in 24h. BTC dominance 52%, declining — altcoin rotation accelerating. Average funding rate +0.008% — slightly long-biased but not extreme. Risk-on environment.",
  "btc_eth_summary": {
    "btc": {"price": "$97,500", "change_24h": "+2.1%", "change_7d": "+8.3%", "dominance": "52%", "funding_rate": "+0.01%", "signal": "Stage 2 uptrend. Funding neutral. Healthy."},
    "eth": {"price": "$3,850", "change_24h": "+4.2%", "change_7d": "+12.1%", "funding_rate": "+0.015%", "signal": "Outperforming BTC. ETH/BTC ratio recovering. Bullish."}
  },
  "funding_rate_analysis": {
    "market_bias": "Slightly long-biased (avg funding +0.008%)",
    "crowded_longs": [
      {"symbol": "DOGEUSDT", "funding": "+0.045%", "signal": "Extremely crowded longs. High liquidation risk on any dip.", "action": "Avoid new longs or take profit"}
    ],
    "squeeze_candidates": [
      {"symbol": "SOLUSDT", "funding": "-0.02%", "oi_change": "+15%", "signal": "Shorts piling in but price holding. Squeeze potential.", "action": "Watch for breakout above $185 as squeeze trigger"}
    ]
  },
  "hot_categories": [
    {"name": "AI Tokens", "market_cap_change_24h": "+8.2%", "top_coins": "RNDR, FET, OCEAN", "signal": "Leading narrative rotation"},
    {"name": "Meme Coins", "market_cap_change_24h": "+5.1%", "top_coins": "DOGE, SHIB, PEPE", "signal": "Risk-on indicator — retail FOMO active"}
  ],
  "top_momentum": [
    {
      "coin": "Solana",
      "symbol": "SOL",
      "price": "$185",
      "change_24h": "+6.8%",
      "change_7d": "+18.2%",
      "change_30d": "+42%",
      "market_cap": "$82B",
      "volume_24h": "$4.2B",
      "funding_rate": "-0.02%",
      "open_interest": "$2.1B",
      "social": {
        "twitter_followers": "2.8M",
        "reddit_subscribers": "180K",
        "dev_activity": "High (450 commits/month)",
        "sentiment": "82% bullish"
      },
      "conviction": "High",
      "thesis": "Negative funding despite strong price action = shorts getting squeezed. Dev activity highest in 6 months. DeFi TVL growing. Outperforming ETH on 30d basis.",
      "setup": "Breakout above $180 resistance on volume. Funding negative = fuel for squeeze.",
      "risk": "Concentrated in one validator client. Network outage history.",
      "trade_plan": {
        "entry": "$180-$186",
        "stop": "$168",
        "target_1": "$210",
        "target_2": "$250",
        "risk_reward": "1:3.5"
      }
    }
  ],
  "on_chain_signals": {
    "exchange_flows": "Net outflows from exchanges — accumulation pattern (bullish)",
    "stablecoin_supply": "USDT supply at ATH — dry powder on sidelines",
    "btc_whale_activity": "Wallets >1000 BTC increasing — institutional accumulation"
  },
  "upcoming_catalysts": [
    "ETH Pectra upgrade — March 2025",
    "BTC halving impact still playing out — supply squeeze",
    "Fed rate decision Feb 28 — risk-on if dovish"
  ]
}
```

RULES FOR CRYPTO FORMAT:
- Always start with BTC and ETH summary (they set the market tone)
- Funding rate analysis is CRITICAL — this is the edge over basic price tracking
  - Positive funding > 0.03% = crowded longs, correction risk
  - Negative funding < -0.01% = crowded shorts, squeeze potential
  - Flat funding near 0 = healthy, trend likely to continue
- Show which CATEGORIES are leading — AI, memes, L2, DeFi, gaming — this shows narrative rotation
- For each top momentum coin include: price changes (24h, 7d, 30d), funding rate, OI, social metrics, dev activity
- Social metrics matter more in crypto than equities — include Twitter followers, Reddit subs, GitHub commits
- Include on_chain_signals section even if data is limited — stablecoin supply, exchange flows, whale activity (use the global market data and derivatives data to infer these)
- Flag any coin where funding rate DISAGREES with price action (divergence = strongest signal)
- Include trade_plan for top conviction picks
```

### STEP 9: Add Crypto Interpretation to System Prompt

**Add this section alongside the other analysis guidance in the system prompt:**
```
## CRYPTO MARKET INTERPRETATION

**Funding Rates — The Most Important Signal:**
- Funding rate = periodic fee between longs and shorts on perps to keep price aligned with spot
- Positive funding: Longs pay shorts. More leveraged longs than shorts. Bullish consensus.
- Negative funding: Shorts pay longs. More leveraged shorts. Bearish consensus OR squeeze setup.
- KEY INSIGHT: When price is RISING but funding is NEGATIVE, shorts are getting squeezed. This is the highest-conviction long setup in crypto.
- KEY INSIGHT: When price is STALLING but funding is VERY POSITIVE (>0.03%), longs are crowded. A flush/liquidation cascade is likely. This is when to take profits or go short.
- Neutral funding (near 0%) with rising price = healthiest trend. No crowding. Sustainable move.

**Open Interest Analysis:**
- Rising OI + Rising Price = New money entering, trend confirmation (bullish)
- Rising OI + Falling Price = Shorts building, potential for squeeze if price reverses
- Falling OI + Falling Price = Longs closing/liquidating, bearish but capitulation may be near
- Falling OI + Rising Price = Short squeeze / short covering rally (often unsustainable)

**Category/Narrative Rotation:**
- Crypto trades on narratives more than fundamentals
- When AI tokens are leading: risk-on, institutional interest
- When meme coins are leading: late-cycle retail FOMO, caution warranted
- When DeFi is leading: yield-seeking, rates environment matters
- When L2/infra is leading: builder interest, earlier cycle signal

**Social Metrics in Crypto:**
- GitHub commits = actual development activity (hardest to fake)
- Twitter followers + Reddit = community size (can be gamed but directional)
- Trending on CoinGecko = retail search interest spiking (early momentum signal)
- Dev activity increasing + price flat = potential asymmetric setup (builders ahead of market)
Re-publish/deploy the backend.