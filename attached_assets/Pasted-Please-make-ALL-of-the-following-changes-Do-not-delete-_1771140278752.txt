Please make ALL of the following changes. Do not delete or modify any existing code unless I specifically say "replace."
PART 1: Create the Scoring Engine
Create a new file data/scoring_engine.py with this content:
python"""
Quantitative scoring engine for ranking stock candidates.
Runs BEFORE Claude — no AI calls, pure math.

Each query type has a different scoring formula that weights
indicators differently. A "best trades" query weights volume
and momentum heavily. A "best investments" query weights
fundamentals and valuation.

This lets us cast a wide net (50-100 candidates), score them
all cheaply, and send only the top 10-15 to Claude for deep
qualitative analysis.
"""


def score_for_trades(ticker_data: dict) -> float:
    """
    Score a ticker for short-term trading potential.
    Weights: momentum (30%), volume (25%), technicals (25%), sentiment (20%)
    Returns 0-100 score.
    """
    score = 0.0
    snapshot = ticker_data.get("snapshot", {})
    technicals = ticker_data.get("technicals", {})
    sentiment = ticker_data.get("sentiment", {}) or ticker_data.get("stocktwits", {})
    details = ticker_data.get("details", {})

    # --- Momentum (30 pts max) ---
    change_pct = snapshot.get("change_pct")
    if change_pct is not None:
        try:
            change = float(change_pct)
            if change > 0:
                # Positive momentum, scale 0-30 (cap at +20%)
                score += min(change * 1.5, 30)
            else:
                # Negative momentum reduces score
                score += max(change * 0.5, -10)
        except (TypeError, ValueError):
            pass

    # --- Volume (25 pts max) ---
    volume = snapshot.get("volume")
    avg_vol = None
    if details:
        avg_vol = details.get("avg_volume")
    if volume and avg_vol:
        try:
            ratio = float(volume) / float(avg_vol)
            if ratio >= 5.0:
                score += 25
            elif ratio >= 3.0:
                score += 20
            elif ratio >= 2.0:
                score += 15
            elif ratio >= 1.5:
                score += 10
            elif ratio >= 1.0:
                score += 5
            else:
                score += 0
        except (TypeError, ValueError, ZeroDivisionError):
            pass

    # --- Technicals (25 pts max) ---
    rsi = technicals.get("rsi")
    sma_20 = technicals.get("sma_20")
    sma_50 = technicals.get("sma_50")
    macd = technicals.get("macd")
    macd_signal = technicals.get("macd_signal")
    price = snapshot.get("price")

    if rsi is not None:
        try:
            rsi = float(rsi)
            if 40 <= rsi <= 70:
                score += 8  # Healthy momentum zone
            elif 30 <= rsi < 40:
                score += 5  # Recovering
            elif rsi > 70:
                score += 3  # Strong but overbought risk
            # RSI < 30 gets 0 for trades (falling knife)
        except (TypeError, ValueError):
            pass

    if price and sma_20:
        try:
            if float(price) > float(sma_20):
                score += 6  # Above short-term trend
        except (TypeError, ValueError):
            pass

    if price and sma_50:
        try:
            if float(price) > float(sma_50):
                score += 5  # Above medium-term trend
        except (TypeError, ValueError):
            pass

    if macd is not None and macd_signal is not None:
        try:
            if float(macd) > float(macd_signal):
                score += 6  # Bullish MACD crossover
        except (TypeError, ValueError):
            pass

    # --- Sentiment (20 pts max) ---
    if isinstance(sentiment, dict):
        bull_pct = sentiment.get("bull_pct") or sentiment.get("bullish_pct")
        if bull_pct is not None:
            try:
                bull = float(bull_pct)
                if bull >= 75:
                    score += 20
                elif bull >= 60:
                    score += 14
                elif bull >= 50:
                    score += 8
                else:
                    score += 2
            except (TypeError, ValueError):
                pass

    return round(min(score, 100), 1)


def score_for_investments(ticker_data: dict) -> float:
    """
    Score a ticker for long-term investment potential.
    Weights: fundamentals (35%), valuation (25%), quality (20%), momentum (10%), insider (10%)
    Returns 0-100 score.
    """
    score = 0.0
    overview = ticker_data.get("overview", {})
    snapshot = ticker_data.get("snapshot", {})
    technicals = ticker_data.get("technicals", {})
    insider = ticker_data.get("insider_sentiment", {})
    earnings = ticker_data.get("earnings_history", [])
    details = ticker_data.get("details", {})

    if not isinstance(overview, dict):
        overview = {}

    # --- Fundamentals: Revenue Growth + Margins (35 pts max) ---
    rev_growth = overview.get("revenue_growth")
    if rev_growth is not None:
        try:
            rg = float(rev_growth)
            if rg > 0.40:
                score += 15
            elif rg > 0.25:
                score += 12
            elif rg > 0.15:
                score += 9
            elif rg > 0.05:
                score += 5
        except (TypeError, ValueError):
            pass

    ebitda_margin = overview.get("ebitda_margin")
    if ebitda_margin is not None:
        try:
            em = float(ebitda_margin)
            if em > 0.30:
                score += 10
            elif em > 0.20:
                score += 8
            elif em > 0.10:
                score += 5
            elif em > 0:
                score += 3
            # Negative EBITDA = 0 pts
        except (TypeError, ValueError):
            pass

    profit_margin = overview.get("profit_margin")
    if profit_margin is not None:
        try:
            pm = float(profit_margin)
            if pm > 0.20:
                score += 10
            elif pm > 0.10:
                score += 7
            elif pm > 0:
                score += 3
        except (TypeError, ValueError):
            pass

    # --- Valuation (25 pts max) ---
    ps_ratio = overview.get("ps_ratio")
    if ps_ratio is not None:
        try:
            ps = float(ps_ratio)
            if ps < 2:
                score += 12
            elif ps < 5:
                score += 9
            elif ps < 10:
                score += 5
            elif ps < 20:
                score += 2
            # > 20x P/S = 0 pts (expensive)
        except (TypeError, ValueError):
            pass

    pe_ratio = overview.get("pe_ratio")
    if pe_ratio is not None:
        try:
            pe = float(pe_ratio)
            if 0 < pe < 15:
                score += 13
            elif 15 <= pe < 25:
                score += 10
            elif 25 <= pe < 40:
                score += 6
            elif 40 <= pe < 60:
                score += 2
        except (TypeError, ValueError):
            pass

    # --- Quality: Earnings Consistency (20 pts max) ---
    if isinstance(earnings, list) and len(earnings) > 0:
        recent = earnings[:4]
        beats = sum(
            1 for e in recent
            if isinstance(e, dict) and e.get("surprise_pct") and e["surprise_pct"] > 0
        )
        score += beats * 5  # Up to 20 pts for 4/4 beats

    # --- Momentum (10 pts max) ---
    price = snapshot.get("price")
    sma_50 = technicals.get("sma_50")
    if price and sma_50:
        try:
            if float(price) > float(sma_50):
                score += 10
            else:
                score += 2
        except (TypeError, ValueError):
            pass

    # --- Insider Activity (10 pts max) ---
    if isinstance(insider, dict):
        mspr = insider.get("mspr")
        if mspr is not None:
            try:
                mspr = float(mspr)
                if mspr > 5:
                    score += 10  # Strong insider buying
                elif mspr > 0:
                    score += 6
                elif mspr < -5:
                    score += 0  # Heavy selling
                else:
                    score += 3
            except (TypeError, ValueError):
                pass

    return round(min(score, 100), 1)


def score_for_squeeze(ticker_data: dict) -> float:
    """
    Score a ticker for short squeeze potential.
    Weights: short interest (30%), volume (25%), price action (20%), social (15%), technicals (10%)
    """
    score = 0.0
    overview = ticker_data.get("overview", {})
    snapshot = ticker_data.get("snapshot", {})
    technicals = ticker_data.get("technicals", {})
    sentiment = ticker_data.get("sentiment", {}) or ticker_data.get("stocktwits", {})
    details = ticker_data.get("details", {})

    if not isinstance(overview, dict):
        overview = {}

    # --- Short Interest (30 pts max) ---
    short_float = overview.get("short_float")
    if short_float is not None:
        try:
            sf = float(str(short_float).replace("%", ""))
            if sf > 30:
                score += 30
            elif sf > 20:
                score += 24
            elif sf > 15:
                score += 18
            elif sf > 10:
                score += 10
        except (TypeError, ValueError):
            pass

    # --- Volume Surge (25 pts max) ---
    volume = snapshot.get("volume")
    avg_vol = details.get("avg_volume") if details else None
    if volume and avg_vol:
        try:
            ratio = float(volume) / float(avg_vol)
            if ratio >= 5.0:
                score += 25
            elif ratio >= 3.0:
                score += 20
            elif ratio >= 2.0:
                score += 15
            elif ratio >= 1.5:
                score += 8
        except (TypeError, ValueError, ZeroDivisionError):
            pass

    # --- Price Action (20 pts max) ---
    change_pct = snapshot.get("change_pct")
    if change_pct is not None:
        try:
            change = float(change_pct)
            if change > 10:
                score += 20
            elif change > 5:
                score += 15
            elif change > 2:
                score += 10
            elif change > 0:
                score += 5
        except (TypeError, ValueError):
            pass

    # --- Social Buzz (15 pts max) ---
    if isinstance(sentiment, dict):
        bull_pct = sentiment.get("bull_pct") or sentiment.get("bullish_pct")
        if bull_pct is not None:
            try:
                bull = float(bull_pct)
                if bull >= 80:
                    score += 15
                elif bull >= 65:
                    score += 10
                elif bull >= 50:
                    score += 5
            except (TypeError, ValueError):
                pass

    # --- Technicals (10 pts max) ---
    price = snapshot.get("price")
    sma_20 = technicals.get("sma_20")
    rsi = technicals.get("rsi")

    if price and sma_20:
        try:
            if float(price) > float(sma_20):
                score += 5
        except (TypeError, ValueError):
            pass

    if rsi is not None:
        try:
            rsi = float(rsi)
            if 50 <= rsi <= 75:
                score += 5  # Momentum but not exhausted
        except (TypeError, ValueError):
            pass

    return round(min(score, 100), 1)


def score_for_fundamentals(ticker_data: dict) -> float:
    """
    Score a ticker for improving fundamentals.
    Weights: revenue acceleration (30%), margin expansion (30%), earnings beats (20%), valuation (20%)
    """
    score = 0.0
    overview = ticker_data.get("overview", {})
    earnings = ticker_data.get("earnings_history", [])

    if not isinstance(overview, dict):
        overview = {}

    # --- Revenue Growth (30 pts max) ---
    rev_growth = overview.get("revenue_growth")
    if rev_growth is not None:
        try:
            rg = float(rev_growth)
            if rg > 0.50:
                score += 30
            elif rg > 0.30:
                score += 25
            elif rg > 0.20:
                score += 20
            elif rg > 0.10:
                score += 12
            elif rg > 0:
                score += 5
        except (TypeError, ValueError):
            pass

    # --- Margin Expansion (30 pts max) ---
    ebitda_margin = overview.get("ebitda_margin")
    profit_margin = overview.get("profit_margin")

    if ebitda_margin is not None:
        try:
            em = float(ebitda_margin)
            if em > 0.30:
                score += 15
            elif em > 0.15:
                score += 12
            elif em > 0.05:
                score += 8
            elif em > 0:
                score += 5  # Just turned positive = big signal
        except (TypeError, ValueError):
            pass

    if profit_margin is not None:
        try:
            pm = float(profit_margin)
            if pm > 0.20:
                score += 15
            elif pm > 0.10:
                score += 12
            elif pm > 0:
                score += 8
        except (TypeError, ValueError):
            pass

    # --- Earnings Beats (20 pts max) ---
    if isinstance(earnings, list) and len(earnings) > 0:
        recent = earnings[:4]
        beats = sum(
            1 for e in recent
            if isinstance(e, dict) and e.get("surprise_pct") and e["surprise_pct"] > 0
        )
        score += beats * 5

    # --- Valuation (20 pts max) ---
    ps_ratio = overview.get("ps_ratio")
    if ps_ratio is not None:
        try:
            ps = float(ps_ratio)
            if ps < 3:
                score += 20
            elif ps < 6:
                score += 14
            elif ps < 10:
                score += 8
            elif ps < 15:
                score += 3
        except (TypeError, ValueError):
            pass

    return round(min(score, 100), 1)


def score_for_bearish(ticker_data: dict) -> float:
    """
    Score a ticker for bearish/breakdown potential.
    Higher score = more bearish setup.
    """
    score = 0.0
    snapshot = ticker_data.get("snapshot", {})
    technicals = ticker_data.get("technicals", {})
    details = ticker_data.get("details", {})

    # Negative price action
    change_pct = snapshot.get("change_pct")
    if change_pct is not None:
        try:
            change = float(change_pct)
            if change < 0:
                score += min(abs(change) * 2, 25)
        except (TypeError, ValueError):
            pass

    # Below moving averages
    price = snapshot.get("price")
    sma_20 = technicals.get("sma_20")
    sma_50 = technicals.get("sma_50")

    if price and sma_20:
        try:
            if float(price) < float(sma_20):
                score += 15
        except (TypeError, ValueError):
            pass

    if price and sma_50:
        try:
            if float(price) < float(sma_50):
                score += 15
        except (TypeError, ValueError):
            pass

    # Overbought RSI (potential reversal)
    rsi = technicals.get("rsi")
    if rsi is not None:
        try:
            rsi = float(rsi)
            if rsi > 80:
                score += 20
            elif rsi > 70:
                score += 12
        except (TypeError, ValueError):
            pass

    # Bearish MACD
    macd = technicals.get("macd")
    macd_signal = technicals.get("macd_signal")
    if macd is not None and macd_signal is not None:
        try:
            if float(macd) < float(macd_signal):
                score += 15
        except (TypeError, ValueError):
            pass

    # High volume on down day (distribution)
    volume = snapshot.get("volume")
    avg_vol = details.get("avg_volume") if details else None
    if volume and avg_vol and change_pct:
        try:
            if float(change_pct) < 0 and float(volume) / float(avg_vol) > 2.0:
                score += 10  # Distribution signal
        except (TypeError, ValueError, ZeroDivisionError):
            pass

    return round(min(score, 100), 1)


# Mapping of query categories to scoring functions
SCORING_FUNCTIONS = {
    "market_scan": score_for_trades,
    "trades": score_for_trades,
    "investments": score_for_investments,
    "squeeze": score_for_squeeze,
    "fundamentals_scan": score_for_fundamentals,
    "bearish": score_for_bearish,
    "small_cap_spec": score_for_trades,
    "asymmetric": score_for_investments,
    "volume_spikes": score_for_trades,
    "social_momentum": score_for_trades,
}


def rank_candidates(candidates: dict, category: str, top_n: int = 12) -> list:
    """
    Takes a dict of {ticker: raw_data}, scores each ticker
    for the given category, and returns the top N ranked by score.

    Returns list of (ticker, score, raw_data) tuples, sorted descending.
    """
    scoring_fn = SCORING_FUNCTIONS.get(category, score_for_trades)

    scored = []
    for ticker, data in candidates.items():
        if not isinstance(data, dict):
            continue
        try:
            s = scoring_fn(data)
            scored.append((ticker, s, data))
        except Exception as e:
            print(f"Scoring error for {ticker}: {e}")
            continue

    # Sort by score descending
    scored.sort(key=lambda x: x[1], reverse=True)

    return scored[:top_n]
PART 2: Widen the Funnel — Pull More Candidates
In data/market_data_service.py, add this new method:
python    async def wide_scan_and_rank(self, category: str, filters: dict = None) -> dict:
        """
        WIDE FUNNEL approach:
        1. Cast wide net — pull 50-100+ candidates from multiple screeners
        2. Do lightweight enrichment on all of them
        3. Score them quantitatively
        4. Return top 12-15 fully enriched to Claude

        This ensures we never miss a good setup just because it wasn't
        in the top 5 of one screener.
        """
        import asyncio
        from data.scoring_engine import rank_candidates

        # ── Stage 1: Cast Wide Net (parallel screener calls) ──
        # Pull from EVERY relevant screener simultaneously
        screener_results = await asyncio.gather(
            self.finviz.get_screener_results("ta_topgainers"),
            self.finviz.get_unusual_volume(),
            self.finviz.get_new_highs(),
            self.finviz.get_most_active(),
            self.finviz.get_top_losers() if category == "bearish" else asyncio.sleep(0),
            self.finviz.get_overbought_stocks() if category == "bearish" else asyncio.sleep(0),
            self.finviz.get_oversold_stocks() if category in ["trades", "market_scan", "asymmetric"] else asyncio.sleep(0),
            self.finviz.get_small_cap_gainers() if category in ["small_cap_spec", "trades", "market_scan"] else asyncio.sleep(0),
            self.finviz.get_high_short_float() if category in ["squeeze", "trades", "market_scan"] else asyncio.sleep(0),
            self.finviz.get_insider_buying() if category in ["investments", "fundamentals_scan", "asymmetric"] else asyncio.sleep(0),
            self.finviz.get_analyst_upgrades() if category in ["investments", "fundamentals_scan"] else asyncio.sleep(0),
            self.finviz.get_earnings_this_week() if category in ["investments", "fundamentals_scan"] else asyncio.sleep(0),
            return_exceptions=True,
        )

        # Also get StockTwits trending for social discovery
        trending = []
        try:
            trending = await self.stocktwits.get_trending()
        except:
            pass

        # Also get Polygon movers for additional coverage
        movers = {}
        try:
            movers = self.polygon.get_market_movers()
        except:
            pass

        # ── Stage 2: Deduplicate all tickers into one universe ──
        all_tickers = set()

        for result in screener_results:
            if isinstance(result, list):
                for item in result:
                    if isinstance(item, dict) and item.get("ticker"):
                        ticker = item["ticker"].upper().strip()
                        if len(ticker) <= 5 and ticker.isalpha():
                            all_tickers.add(ticker)

        # Add trending tickers
        for t in (trending or []):
            if isinstance(t, dict) and t.get("ticker"):
                all_tickers.add(t["ticker"].upper().strip())

        # Add polygon movers
        for g in (movers.get("gainers") or []):
            if g.get("ticker"):
                all_tickers.add(g["ticker"].upper().strip())
        if category == "bearish":
            for l in (movers.get("losers") or []):
                if l.get("ticker"):
                    all_tickers.add(l["ticker"].upper().strip())

        # Apply market cap filter if specified
        # (We'll filter after enrichment since we need details)

        print(f"[Wide Scan] {category}: {len(all_tickers)} unique candidates found")

        # ── Stage 3: Lightweight enrichment for ALL candidates ──
        # This is fast: just Polygon snapshot + technicals + details (sync, ~0.5s each)
        async def light_enrich(ticker):
            try:
                snapshot = self.polygon.get_snapshot(ticker)
                technicals = self.polygon.get_technicals(ticker)
                details = self.polygon.get_ticker_details(ticker)
                return {
                    "snapshot": snapshot,
                    "technicals": technicals,
                    "details": details,
                }
            except Exception as e:
                return {"error": str(e)}

        # Enrich all candidates in parallel (batched to avoid rate limits)
        ticker_list = list(all_tickers)[:60]  # Cap at 60 to stay within rate limits
        enrichment_results = await asyncio.gather(
            *[asyncio.to_thread(lambda t=t: light_enrich(t)) for t in ticker_list],
            return_exceptions=True,
        )

        candidates = {}
        for ticker, result in zip(ticker_list, enrichment_results):
            if not isinstance(result, Exception) and isinstance(result, dict) and "error" not in result:
                candidates[ticker] = result

        print(f"[Wide Scan] {len(candidates)} candidates enriched successfully")

        # ── Stage 4: Score and rank ──
        top_ranked = rank_candidates(candidates, category, top_n=15)

        print(f"[Wide Scan] Top 15 scores: {[(t, s) for t, s, _ in top_ranked[:15]]}")

        # ── Stage 5: Deep enrichment for top 12 only ──
        top_tickers = [(ticker, score) for ticker, score, _ in top_ranked[:12]]

        async def deep_enrich(ticker):
            """Full enrichment with all data sources."""
            try:
                st_result, overview, analyst, insider, earnings, recommendations = (
                    await asyncio.gather(
                        self.stocktwits.get_sentiment(ticker),
                        self.stockanalysis.get_overview(ticker),
                        self.stockanalysis.get_analyst_ratings(ticker),
                        asyncio.to_thread(lambda: self.finnhub.get_insider_sentiment(ticker)),
                        asyncio.to_thread(lambda: self.finnhub.get_earnings_surprises(ticker)),
                        asyncio.to_thread(lambda: self.finnhub.get_recommendation_trends(ticker)),
                        return_exceptions=True,
                    )
                )
                return {
                    "sentiment": st_result if not isinstance(st_result, Exception) else {},
                    "overview": overview if not isinstance(overview, Exception) else {},
                    "analyst_ratings": analyst if not isinstance(analyst, Exception) else {},
                    "insider_sentiment": insider if not isinstance(insider, Exception) else {},
                    "earnings_history": earnings if not isinstance(earnings, Exception) else [],
                    "recommendations": recommendations if not isinstance(recommendations, Exception) else [],
                }
            except Exception as e:
                return {"error": str(e)}

        deep_results = await asyncio.gather(
            *[deep_enrich(t) for t, _ in top_tickers],
            return_exceptions=True,
        )

        # Merge deep enrichment into candidate data
        enriched_candidates = {}
        for (ticker, quant_score), deep_data in zip(top_tickers, deep_results):
            base_data = candidates.get(ticker, {})
            if not isinstance(deep_data, Exception) and isinstance(deep_data, dict):
                base_data.update(deep_data)
            base_data["quant_score"] = quant_score
            enriched_candidates[ticker] = base_data

        # ── Return structured data ──
        return {
            "total_candidates_scanned": len(all_tickers),
            "candidates_scored": len(candidates),
            "top_ranked": [
                {"ticker": t, "score": s} for t, s, _ in top_ranked[:15]
            ],
            "enriched_data": enriched_candidates,
            "movers": movers,
            "trending": trending[:10] if trending else [],
        }
PART 3: Wire Wide Scan into the Agent
In agent/claude_agent.py, find the _gather_data method. Replace the existing blocks for these categories with the wide scan approach. Find and replace these specific elif blocks:
Find:
python        elif category == "market_scan":
            return await self.data.scan_market()
Replace with:
python        elif category == "market_scan":
            return await self.data.wide_scan_and_rank("market_scan", filters)
Do the same for these categories — find each elif and replace:
python        elif category == "investments":
            return await self.data.wide_scan_and_rank("investments", filters)

        elif category == "fundamentals_scan":
            return await self.data.wide_scan_and_rank("fundamentals_scan", filters)

        elif category == "squeeze":
            return await self.data.wide_scan_and_rank("squeeze", filters)

        elif category == "asymmetric":
            return await self.data.wide_scan_and_rank("asymmetric", filters)

        elif category == "bearish":
            return await self.data.wide_scan_and_rank("bearish", filters)

        elif category == "small_cap_spec":
            return await self.data.wide_scan_and_rank("small_cap_spec", filters)

        elif category == "volume_spikes":
            return await self.data.wide_scan_and_rank("volume_spikes", filters)

        elif category == "social_momentum":
            return await self.data.wide_scan_and_rank("social_momentum", filters)
Keep the existing elif blocks for categories that don't need wide scanning (ticker_analysis, macro, commodities, sector_rotation, earnings_catalyst, thematic, dashboard, general, etc.).
Also make sure the _gather_data method accepts filters from the classification. Find where query_info is used and add:
python        filters = query_info.get("filters", {})
```

**(Add this line at the top of the `_gather_data` method, right after `category = query_info.get("category", "general")`)**

## PART 4: Tell Claude About the Scoring

**In `agent/prompts.py`, add this section to the SYSTEM_PROMPT, right before the `## RESPONSE FORMAT SYSTEM` section:**
```
## QUANTITATIVE PRE-SCORING

Before you receive data, a scoring engine has already:
1. Scanned 50-100+ candidates from multiple screeners (gainers, unusual volume, new highs, most active, high short float, insider buying, StockTwits trending, Polygon movers)
2. Enriched ALL candidates with price, volume, and technical data
3. Scored each candidate quantitatively based on the query type
4. Sent you only the TOP 12 ranked by aggregate score

Each ticker includes a `quant_score` (0-100) reflecting its quantitative ranking. Higher = stronger setup for the given query type.

The data also includes `total_candidates_scanned` and `top_ranked` showing the full ranking. You should mention this in your response — e.g. "Scanned 87 candidates, scored and ranked. Here are the top picks."

YOUR JOB: Add the qualitative layer. The scoring engine handles the math. You add:
- Thesis and narrative (WHY this is a good setup)
- Context (what's the catalyst, what's the sector doing)
- Risk assessment (what could go wrong)
- Trade plan (entry, stop, targets)
- Pattern recognition the quant score can't capture
- Conviction adjustment (sometimes a lower quant score has a better story)

You may reorder picks if your qualitative analysis suggests a lower-scored ticker has a stronger setup. Explain why if you do.
```

**Re-publish/deploy the backend.**

---

## What This Changes

**Before (current):**
```
Finviz top 20 gainers → enrich 5-8 → Claude picks from 5-8
Result: Narrow funnel, misses good setups
```

**After (new):**
```
12 screeners in parallel → 50-100 unique candidates → light enrich all → score all → deep enrich top 12 → Claude analyzes 12
Result: Wide funnel, quantitatively ranked, nothing slips through
