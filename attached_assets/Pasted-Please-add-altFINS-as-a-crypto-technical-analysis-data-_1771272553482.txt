Please add altFINS as a crypto technical analysis data source. This replaces the need to calculate any crypto indicators ourselves — altFINS provides 90+ pre-computed indicators, trend scores, chart patterns, and trading signals per coin. Free tier: 1,000 credits/month, 30 req/min.
STEP 0: Add the API key
In the Secrets panel, add:

Key: ALTFINS_API_KEY
Value: (the user will provide this directly)

In config.py:
pythonALTFINS_API_KEY = os.getenv("ALTFINS_API_KEY")
STEP 1: Create the altFINS provider
Create a new file data/altfins_provider.py:
python"""
altFINS API provider for crypto technical analysis data.
Free tier: 1,000 credits/month, 30 requests/minute.
Provides: 90+ technical indicators, trend scores, chart patterns,
candlestick patterns, signals, support/resistance per coin.

Swagger docs: https://altfins.com/swagger-ui/index.html?urls.primaryName=publicApiV1
API base: https://api.altfins.com/v1
"""
import httpx
from data.cache import cache

# Cache aggressively to conserve credits
ALTFINS_CACHE_TTL = 600  # 10 minutes for indicator data
ALTFINS_SIGNALS_CACHE_TTL = 900  # 15 minutes for signals (they don't change fast)


class AltFINSProvider:
    BASE_URL = "https://api.altfins.com/v1"

    def __init__(self, api_key: str):
        self.api_key = api_key

    async def _get(self, endpoint: str, params: dict = None, cache_key: str = None, ttl: int = ALTFINS_CACHE_TTL) -> dict | list:
        if cache_key:
            cached = cache.get(cache_key)
            if cached is not None:
                return cached

        headers = {
            "Accept": "application/json",
            "X-API-KEY": self.api_key,
        }

        try:
            async with httpx.AsyncClient(timeout=15.0) as client:
                resp = await client.get(
                    f"{self.BASE_URL}/{endpoint}",
                    params=params or {},
                    headers=headers,
                )

            if resp.status_code == 401:
                print(f"[ALTFINS] Authentication failed — check API key")
                return []
            if resp.status_code == 429:
                print(f"[ALTFINS] Rate limited")
                return []
            if resp.status_code != 200:
                print(f"[ALTFINS] Error {resp.status_code}: {endpoint}")
                return []

            data = resp.json()
            if cache_key:
                cache.set(cache_key, data, ttl)
            return data

        except Exception as e:
            print(f"[ALTFINS] Request failed ({endpoint}): {e}")
            return []

    async def get_coin_analytics(self, symbol: str, interval: str = "1d") -> dict:
        """
        Get full analytics for a specific coin.
        Returns: 150+ fields including all indicators, trend scores, 
        support/resistance, performance, etc.
        
        Intervals: 15m, 1h, 4h, 12h, 1d
        Symbol format: uppercase, e.g. "BTC", "ETH", "SOL"
        
        Cost: ~1-3 credits depending on response size.
        """
        data = await self._get(
            "coins/analytics",
            params={
                "symbol": symbol.upper(),
                "interval": interval,
            },
            cache_key=f"altfins:analytics:{symbol}:{interval}",
            ttl=ALTFINS_CACHE_TTL,
        )
        return data

    async def get_screener(self, filter_type: str = "BULLISH_PATTERN_BREAKOUTS", limit: int = 20) -> list:
        """
        Get coins matching a pre-built signal/filter.
        
        Key filter types:
        - BULLISH_PATTERN_BREAKOUTS: Coins breaking out of bullish chart patterns
        - BEARISH_PATTERN_BREAKOUTS: Bearish breakouts
        - BULLISH_EMERGING_PATTERNS: Patterns forming, not yet broken out
        - FRESH_BULLISH_EMA_CROSSOVER: Recent bullish EMA crossovers
        - FRESH_BULLISH_MACD_SIGNAL_LINE_CROSSOVER: MACD just turned bullish
        - FRESH_GOLDEN_CROSSOVER: SMA 50 crossed above SMA 200
        - FRESH_DEATH_CROSSOVER: SMA 50 crossed below SMA 200 (bearish)
        - BULLISH_MOMENTUM_RSI_CONFIRMATION: RSI confirming bullish momentum
        - EARLY_BULLISH_MOMENTUM_INFLECTION: Early signs of momentum shift up
        - EARLY_BEARISH_MOMENTUM_INFLECTION: Early signs of momentum shift down
        - BOLLINGER_BAND_BREAKOUT_ABOVE: Breaking above upper Bollinger band
        - BOLLINGER_BAND_BREAKOUT_BELOW: Breaking below lower Bollinger band
        - NEW_ATH: New all-time highs
        - ATH_NOT_OVERBOUGHT: Near ATH but RSI not overbought
        - TOP_GAINERS: Biggest price gainers
        - TOP_LOSERS: Biggest price losers
        - OVERSOLD_NEAR_SUPPORT: Oversold coins near support levels
        - STRONG_UPTREND: Coins in established strong uptrends
        - PULLBACK_IN_UPTREND: Uptrending coins pulling back (buy the dip candidates)
        
        Cost: ~1-5 credits per call depending on result size.
        """
        data = await self._get(
            "screener",
            params={
                "type": filter_type,
                "limit": limit,
            },
            cache_key=f"altfins:screener:{filter_type}:{limit}",
            ttl=ALTFINS_SIGNALS_CACHE_TTL,
        )
        return data

    async def get_signals_summary(self) -> dict:
        """
        Get a summary of all signal counts across all filter types.
        Shows how many coins match each signal at each timeframe.
        Great for market breadth analysis.
        
        Cost: ~1 credit.
        """
        data = await self._get(
            "signals/summary",
            cache_key="altfins:signals_summary",
            ttl=ALTFINS_SIGNALS_CACHE_TTL,
        )
        return data

    async def get_crypto_scanner_data(self) -> dict:
        """
        Main method for the crypto scanner button.
        Pulls the most actionable signals in a single pass.
        Uses ~5-8 credits total, cached for 15 minutes.
        """
        import asyncio

        # Pull the highest-value signals in parallel
        tasks = {
            "bullish_breakouts": self.get_screener("BULLISH_PATTERN_BREAKOUTS", limit=10),
            "fresh_bullish_macd": self.get_screener("FRESH_BULLISH_MACD_SIGNAL_LINE_CROSSOVER", limit=10),
            "oversold_near_support": self.get_screener("OVERSOLD_NEAR_SUPPORT", limit=10),
            "pullback_in_uptrend": self.get_screener("PULLBACK_IN_UPTREND", limit=10),
            "strong_uptrend": self.get_screener("STRONG_UPTREND", limit=10),
            "early_bullish_momentum": self.get_screener("EARLY_BULLISH_MOMENTUM_INFLECTION", limit=10),
            "bearish_breakouts": self.get_screener("BEARISH_PATTERN_BREAKOUTS", limit=10),
        }

        results = {}
        for name, task in tasks.items():
            try:
                results[name] = await asyncio.wait_for(task, timeout=10.0)
            except Exception as e:
                print(f"[ALTFINS] {name} failed: {e}")
                results[name] = []

            # Small delay between calls to respect 30/min rate limit
            await asyncio.sleep(0.3)

        # Deduplicate — find coins appearing in multiple signals (strongest setups)
        coin_signal_count = {}
        for signal_name, coins in results.items():
            if not isinstance(coins, list):
                continue
            for coin in coins:
                symbol = coin.get("symbol") or coin.get("coin") or coin.get("ticker") or ""
                if symbol:
                    if symbol not in coin_signal_count:
                        coin_signal_count[symbol] = {
                            "symbol": symbol,
                            "signals": [],
                            "data": coin,
                        }
                    coin_signal_count[symbol]["signals"].append(signal_name)

        # Sort by number of signals (multi-signal coins = highest conviction)
        multi_signal = sorted(
            coin_signal_count.values(),
            key=lambda x: len(x["signals"]),
            reverse=True,
        )

        return {
            "source": "altFINS",
            "signals": results,
            "multi_signal_coins": multi_signal[:15],
            "signal_summary": {
                name: len(coins) if isinstance(coins, list) else 0
                for name, coins in results.items()
            },
        }

    async def get_coin_deep_dive(self, symbol: str) -> dict:
        """
        Full deep dive on a single coin — daily + 4h analytics.
        Used for watchlist review and single-ticker analysis.
        Cost: ~2-4 credits.
        """
        import asyncio

        daily, four_hour = await asyncio.gather(
            self.get_coin_analytics(symbol, "1d"),
            self.get_coin_analytics(symbol, "4h"),
            return_exceptions=True,
        )

        return {
            "symbol": symbol.upper(),
            "daily": daily if not isinstance(daily, Exception) else {},
            "four_hour": four_hour if not isinstance(four_hour, Exception) else {},
        }
STEP 2: Wire into Market Data Service
In data/market_data_service.py:
pythonfrom data.altfins_provider import AltFINSProvider

# In __init__, add:
self.altfins = AltFINSProvider(altfins_key) if altfins_key else None
Add altfins_key: str = None to the init signature.
STEP 3: Wire into main.py
pythonfrom config import ALTFINS_API_KEY

# In the MarketDataService constructor call, add:
altfins_key=ALTFINS_API_KEY,
STEP 4: Integrate into the crypto scanner pipeline
In the get_crypto_scanner method (or wherever the crypto scan category gathers data), add altFINS alongside CoinGecko and Hyperliquid:
python# Add to the parallel data gathering tasks:
if self.altfins:
    tasks["altfins"] = self.altfins.get_crypto_scanner_data()
STEP 5: Integrate into watchlist/single-ticker analysis
When the agent analyzes a specific crypto ticker (e.g., user asks "Analyze SOL"), add altFINS deep dive data:
python# In the single-ticker analysis path or watchlist enrichment:
if self.altfins and is_crypto_ticker(ticker):
    try:
        altfins_data = await asyncio.wait_for(
            self.altfins.get_coin_deep_dive(ticker),
            timeout=10.0,
        )
        ticker_data["altfins"] = altfins_data
    except:
        pass
```

### STEP 6: Update the system prompt

**Add to the system prompt:**
```
## ALTFINS DATA (PRIMARY CRYPTO TECHNICAL ANALYSIS)

You receive pre-computed technical analysis from altFINS covering 2,000+ crypto assets.
This is your PRIMARY source for crypto TA — do not try to calculate indicators yourself.

altFINS provides for each coin:
- Trend scores: short-term, medium-term, long-term (each scored as Strong Up, Up, Neutral, Down, Strong Down)
- All major indicators pre-computed: RSI (9, 14, 25), MACD + signal + histogram, SMA (5, 10, 20, 50, 100, 200), EMA (9, 12, 26, 50, 100, 200), Stochastic, CCI, OBV, ADX, Bollinger Bands, Williams %R, ATR, momentum
- Chart patterns detected: triangles, wedges, head & shoulders, double bottoms/tops, channels (26 types)
- Candlestick patterns: 30+ types detected automatically
- Support and resistance levels
- Performance: 1d, 1w, 1m, 3m, 6m, 1y, YTD
- Volume analysis: current vs average, change %

KEY SIGNALS FROM ALTFINS (use these for crypto recommendations):

1. **Multi-signal coins** (appearing in multiple signal lists) = HIGHEST CONVICTION
   - A coin showing bullish MACD crossover + pullback in uptrend + oversold near support = strong buy setup

2. **Bullish pattern breakouts** = Active trading opportunities with defined targets
3. **Oversold near support** = Potential bounce candidates (asymmetric risk/reward)
4. **Pullback in uptrend** = Buy-the-dip opportunities in established uptrends
5. **Fresh EMA/MACD crossovers** = Early momentum shifts
6. **Strong uptrend** = Trend-following candidates

HOW TO USE altFINS DATA vs OTHER CRYPTO SOURCES:
- altFINS: Technical analysis, indicators, patterns, signals, trend scores
- Hyperliquid: Funding rates, open interest, derivatives positioning
- CoinGecko: Market cap, prices, market overview, trending coins
- CMC: New listings, trending, social buzz

Cross-reference all four: altFINS says "bullish breakout" + Hyperliquid shows "negative funding" (shorts crowded) + CoinGecko shows "trending" = maximum conviction setup.
STEP 7: Check API endpoint format
IMPORTANT: The exact altFINS API endpoint URLs and parameter names may differ from what I've written above. After adding the API key, the Replit Agent should:

Visit the Swagger docs at https://altfins.com/swagger-ui/index.html?urls.primaryName=publicApiV1
Check the actual endpoint paths, required parameters, and response formats
Adjust the provider code to match the real API
Test with a simple call like getting BTC analytics to verify the key works

Add a test endpoint:
python@app.get("/api/test/altfins")
async def test_altfins():
    if not agent.data.altfins:
        return {"error": "ALTFINS_API_KEY not configured"}
    try:
        data = await agent.data.altfins.get_coin_analytics("BTC", "1d")
        return {
            "status": "ok",
            "fields_returned": len(data) if isinstance(data, dict) else len(data) if isinstance(data, list) else 0,
            "sample": str(data)[:500],
        }
    except Exception as e:
        return {"error": str(e)}
Deploy, then hit /api/test/altfins to verify the connection before doing anything else.
STEP 8: Credit budget management
With 1,000 credits/month, here's the allocation:

Crypto Scanner button: ~7 credits per scan (7 screener calls × ~1 credit each), cached 15 min
Single coin deep dive: ~2-4 credits (2 analytics calls), cached 10 min
With caching, you can comfortably do ~5-8 crypto scans per day and ~10-15 single-coin lookups per day

To stay within budget:

Always check cache before making an API call
Use 15-minute cache for signals, 10-minute for single-coin analytics
Don't pull altFINS data for non-crypto scans (stocks use Finviz/StockAnalysis)
The get_crypto_scanner_data method should only be called when the user clicks Crypto Scanner or asks about crypto

Re-deploy after all changes.